// Потенциальные исключения/ветвления в test(Person const&)

    // [A] std::cout << "test : " << person.name() << '\n';
    // A1: operator<< (cout, "test : ") может бросить ios_base::failure при включённых исключениях потока, bad_alloc, пользовательские
    // A2: person.name() может бросить пользовательское исключение
    // A3: создание/копирование/перемещение результата name() может бросить, например,  bad_alloc / исключения типа результата
    // A4: operator<< (cout, name_result) может бросить ios_base::failure, bad_alloc, пользовательский operator<<
    // A5: operator<< (cout, '\n') может бросить ios_base::failure при включённых исключениях потока
    // A6: внутренняя логика iostream может установить badbit/failbit и при маске exceptions() бросить failure

    // [B] if (person.grade() == 10 || person.salary() > 1'000'000)
    // B1: person.grade() может бросить
    // B2: создание/копирование/перемещение результата grade() может бросить
    // B3: operator== между grade_result и 10 может быть перегружен и бросить
    // B4: преобразование литерала 10 к типу сравнения (конструктор) может бросить
    // B5: person.salary() (если левая часть false) может бросить
    // B6: создание/копирование/перемещение результата salary() может бросить
    // B7: operator> между salary_result и 1'000'000 может быть перегружен и бросить
    // B8: преобразование литерала 1'000'000 к типу сравнения (конструктор) может бросить
    // B9: сам if — ветвление: then или else

    // [C] then-ветка: save(Status::success, person.id());
    // C1: вычисление Status::success (обычно не бросает, но участвует в порядке вычисления аргументов)
    // C2: person.id() может бросить
    // C3: создание/копирование/перемещение результата id() может бросить
    // C4: save(...) может бросить (пользовательские исключения)
    // C5: порядок вычисления аргументов save(...) не фиксирован (может влиять на то, где именно произойдёт исключение)

    // [D] else-ветка: save(Status::failure, person.id());
    // D1: вычисление Status::failure (обычно не бросает, но участвует в порядке вычисления аргументов)
    // D2: person.id() может бросить
    // D3: создание/копирование/перемещение результата id() может бросить
    // D4: save(...) может бросить
    // D5: порядок вычисления аргументов save(...) не фиксирован (аналогично then-ветке)

void test(Person const &person)
{
    std::cout << "test : " << person.name() << ’\n’;

    if (person.grade() == 10 || person.salary() > 1’000’000)
    {
        save(Status ::success, person.id());
    }
    else
    {
        save(Status ::failure, person.id());
    }
}